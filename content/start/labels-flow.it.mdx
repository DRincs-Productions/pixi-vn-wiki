---
title: Gestisci il flusso di gioco con le label
description: Describes how to control the narrative flow in Pixi'VN using labels, including calling, jumping, progressing, and closing labels.
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

Il flusso del gioco è gestito da funzioni quali `callLabel`, `jumpLabel`, `goNext`, `goBack` e `closeLabel`, tutte disponibili nell'oggetto `narration`.

## Esegui una label

<Accordions>

<Accordion title="Call a label" id="call-a-label">

Per richiamare una label, utilizza la funzione `narration.callLabel`.
Questa funzione ha i seguenti parametri:

- `label`: la label da chiamare
- `props`: le proprietà da passare alla label. The interface corresponds to <DynamicLink href="/start/labels#override-steplabelprops">`StepLabelProps`</DynamicLink>.

Quando si chiama una label, viene eseguito il primo step di quella label. If another label was running before the call, the remaining steps of that previous label will resume after the called label finishes.

For example, if the game is running step 5 of label A and you **call** label B, after all steps of label B are executed, the game continues with step 6 of label A.

`narration.callLabel` returns the <DynamicLink href="/start/labels#all-steps-result">result of the first step of the called label</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.callLabel(startLabel, {})
```

If you execute `narration.callLabel` inside a step, you should return the <DynamicLink href="/start/labels#all-steps-result">result of the first step of the called label</DynamicLink> and use `await`. This ensures the history is managed correctly.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.callLabel(TestLabel, props)
        },
        async (props) => await narration.callLabel(TestLabel, props),
    ]
)
```

</Accordion>

<Accordion title="Jump to a label" id="jump-to-a-label">

To jump to a label, use the `narration.jumpLabel` function.
Questa funzione ha i seguenti parametri:

- `label`: the label to jump to
- `props`: le proprietà da passare alla label. The interface corresponds to <DynamicLink href="/start/labels#override-steplabelprops">`StepLabelProps`</DynamicLink>.

When you jump to a label, the current label's steps are stopped and the new label's steps begin.

For example, if the game is running step 5 of label A, and you **call** label B, but then **jump** to label C, after label C finishes, the game continues with step 6 of label A. When you jump to label C, label B is closed.

`narration.jumpLabel` returns the <DynamicLink href="/start/labels#all-steps-result">result of the first step of the called label</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.jumpLabel(startLabel, {})
```

If you execute `narration.jumpLabel` inside a step, you should return the <DynamicLink href="/start/labels#all-steps-result">result of the first step of the called label</DynamicLink> and use `await`. This ensures the first step of the new label is awaited.

```ts title="labels/startLabel.ts"
import { narration } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.jumpLabel(TestLabel, props)
        },
        async (props) => await narration.jumpLabel(TestLabel, props),
    ]
)
```

</Accordion>

</Accordions>

## Next Step and Go Back

### Next step

To execute the next step, use the `narration.goNext()` function.
Questa funzione ha i seguenti parametri:

- `props`: le proprietà da passare alla label. The interface corresponds to <DynamicLink href="/start/labels#override-steplabelprops">`StepLabelProps`</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

await narration.goNext({})
```

`narration.goNext()` is asynchronous, so you can use `.then` to, for example, disable a "Next" button until the step is complete.

```ts
import { narration } from '@drincs/pixi-vn'

// disable next button
narration.goNext({})
    .then((result) => {
        // enable next button
    })
```

If you call `narration.goNext()` inside a step, the "go next" request will be queued and executed when the steps queue is empty.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        narration.goNext(props)
    },
])
```

Here is an example to illustrate how the queue works:

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        await narration.callLabel(label2, props);
        console.log(1);
    },
    () => {
        console.log(3);
    },
])

const label2 = newLabel("label_02", [
    async (props) => {
        await narration.goNext(props);
        console.log(2);
    },
])
```

In this example, the output will be `2`, `1`, `3`. The steps are:

1. `await narration.callLabel(label2, props)` calls label2 and awaits its first step. (1 item in the step queue)
2. The first step of label2 executes `await narration.goNext(props)`, but the goNext request is queued because the step queue is not empty. (2 items in the step queue)
3. `console.log(2)` runs, finishing the first step of label2. (1 item in the step queue)
4. `console.log(1)` runs, finishing the first step of startLabel. (0 items in the step queue)
5. Now the goNext request is executed, and the second step of startLabel runs. (1 item in the step queue)
6. `console.log(3)` runs, finishing the second step of startLabel. (0 items in the step queue)

<Accordions>

<Accordion title="Check if the player can go to the next step" id="check-if-the-player-can-go-to-the-next-step">

You can use the `narration.canGoNext` property to check if the next step can be executed.

`narration.canGoNext` is `false` when:

- A step is running
- The player must <DynamicLink href="/start/choices">make a choice</DynamicLink>
- The player must <DynamicLink href="/start/input">enter a value</DynamicLink>

```tsx title="components/NextButton.tsx"
import { narration } from '@drincs/pixi-vn'

function NextButton() {
    return (
        <button disabled={!narration.canGoNext} onClick={() => {
            narration.goNext({})
        }}>
            Next
        </button>
    )
}
```

</Accordion>

</Accordions>

### Go back

At every step, the system saves the current state of the game. To go back to the previous step, use the `stepHistory.goBack()` function.

You must pass a function `navigate: (path: string) => void` as a parameter. This function will be called with the <DynamicLink href="/start/start/interface-navigate">URL Path or Route</DynamicLink> of the previous step, so you can <DynamicLink href="/start/interface-navigate">navigate to the previous UI screen</DynamicLink>.

For example, if you use [React Router Dom](https://reactrouter.com):

```typescript
import { stepHistory } from '@drincs/pixi-vn'
import { useNavigate } from 'react-router-dom';

const navigate = useNavigate();

if (stepHistory.canGoBack) {
    stepHistory.goBack(navigate).then(() => {
        // ...
    })
}
```

<Accordions>

<Accordion title="Check if the player can go back" id="check-if-the-player-can-go-back">

You can use the `stepHistory.canGoBack` property to check if going back is possible.

`stepHistory.canGoBack` is `false` when there are no steps in the history to restore.

```tsx title="components/BackButton.tsx"
import { stepHistory } from '@drincs/pixi-vn'

function BackButton() {
    return (
        <button disabled={!stepHistory.canGoBack} onClick={() => {
            stepHistory.goBack({})
        }}>
            Back
        </button>
    )
}
```

</Accordion>

<Accordion title="Block the possibility of going back" id="block-the-possibility-of-going-back">

You can block going back by calling `stepHistory.blockGoBack()`.

```typescript
import { stepHistory } from '@drincs/pixi-vn'

stepHistory.blockGoBack()
```

</Accordion>

</Accordions>

## Close labels

<Accordions>

<Accordion title="Close current label" id="close-current-label">

To close the current label, use the `narration.closeCurrentLabel()` function.

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeCurrentLabel()
```

</Accordion>

<Accordion title="Close all labels" id="close-all-labels">

To close all labels, use the `narration.closeAllLabels()` function.\
**If you call this function and do not call any label afterwards, the <DynamicLink href="/start/other-narrative-features#how-manage-the-end-of-the-game">game will end</DynamicLink>.**

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeAllLabels()
```

</Accordion>

</Accordions>

## How to create the go back and go next buttons

This documentation has been moved <DynamicLink href="/start/interface-examples">here</DynamicLink>.
