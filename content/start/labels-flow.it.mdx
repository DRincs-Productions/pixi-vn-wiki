---
title: Gestisci il flusso di narrazione con le label
description: Descrive come controllare il flusso narrativo in Pixi'VN utilizzando le label, tra cui le funzioni di chiamata, salto e chiusura.
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

Il flusso di narrazione è gestito da funzioni quali `callLabel`, `jumpLabel`, `goNext`, `goBack` e `closeLabel`, tutte disponibili nell'oggetto `narration`.

## Esegui una label

<Accordions>

<Accordion title="Call a label" id="call-a-label">

Per richiamare una `label`, utilizza la funzione `narration.callLabel`.
Questa funzione ha i seguenti parametri:

- `label`: la `label` da chiamare
- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

Quando si chiama una `label`, viene eseguito il primo `step` di quella `label`. Se prima della chiamata era in esecuzione un'altra `label`, i `steps` rimanenti della `label` precedente riprenderanno al termine della `label` chiamata.

Ad esempio, se il gioco sta eseguendo lo `step` 5 della `label` A e tu **chiami** la `label` B, dopo che tutti i `passaggi` della `label` B sono stati eseguiti, il gioco continuerà con lo `step` 6 della `label` A.

`narration.callLabel` restituisce il <DynamicLink href="/start/labels#all-steps-result">risultato del primo `step` della `label` chiamata</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.callLabel(startLabel, {})
```

Se esegui `narration.callLabel` all'interno di uno `step`, dovresti restituire il risultato di `narration.callLabel` e utilizzare `await`. In questo modo si garantisce una corretta gestione della cronologia.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.callLabel(TestLabel, props)
        },
        async (props) => await narration.callLabel(TestLabel, props),
    ]
)
```

</Accordion>

<Accordion title="Jump to a label" id="jump-to-a-label">

Per saltare a una `label`, utilizza la funzione `narration.jumpLabel`.
Questa funzione ha i seguenti parametri:

- `label`: la `label` a cui saltare
- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

Quando si salta a una `label`, gli `steps` della `label` corrente vengono interrotti e iniziano gli `steps` della nuova `label`.

Ad esempio, se il gioco sta eseguendo lo `step` 5 della `label` A e tu **chiami** la `label` B, ma poi **salti** alla `label` C, dopo che la `label` C è terminata, il gioco continuerà con lo `step` 6 della `label` A. Quando salti alla `label` C, la `label` B verrà chiusa.

`narration.jumpLabel` restituisce il <DynamicLink href="/start/labels#all-steps-result">risultato del primo `step` della `label` chiamata</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.jumpLabel(startLabel, {})
```

Se esegui `narration.jumpLabel` all'interno di uno `step`, dovresti restituire il risultato di `narration.jumpLabel` e utilizzare `await`. In questo modo si garantisce che si attenda il primo `step` della nuova `label`.

```ts title="labels/startLabel.ts"
import { narration } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.jumpLabel(TestLabel, props)
        },
        async (props) => await narration.jumpLabel(TestLabel, props),
    ]
)
```

</Accordion>

</Accordions>

## Vai allo step successivo e torna indietro

### Go next

<Callout title="UI screen" type="info">

Potete trovare l'esempio del pulsante "Vai avanti" nella sezione <DynamicLink href="/start/interface-examples#go-next">esempi di interfaccia</DynamicLink>.

</Callout>

Per eseguire lo `step` successivo, utilizza la funzione `narration.goNext()`.
Questa funzione ha i seguenti parametri:

- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

await narration.goNext({})
```

`narration.goNext()` è asincrono, quindi puoi usare `.then` per, ad esempio, disabilitare un pulsante "Avanti" finché lo `step` non è completato.

```ts
import { narration } from '@drincs/pixi-vn'

// disable next button
narration.goNext({})
    .then((result) => {
        // enable next button
    })
```

<Accordions>

<Accordion title="Call goNext inside a step" id="call-gonext-inside-a-step">

Se si chiama `narration.goNext()` all'interno di uno `step`, la richiesta "go next" verrà messa in coda ed eseguita quando la coda sarà vuota.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        narration.goNext(props)
    },
])
```

Ecco un esempio per illustrare il funzionamento della coda:

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        await narration.callLabel(label2, props);
        console.log(1);
    },
    () => {
        console.log(3);
    },
])

const label2 = newLabel("label_02", [
    async (props) => {
        await narration.goNext(props);
        console.log(2);
    },
])
```

In questo esempio, l'output sarà `2`, `1`, `3`. I passaggi sono:

1. `await narration.callLabel(label2, props)` chiama label2 e attende il suo primo `step`. (1 elemento nella coda)
2. Il primo `step` di label2 esegue `await narration.goNext(props)`, ma la richiesta goNext viene messa in coda perché la coda non è vuota. (2 elementi in coda)
3. `console.log(2)` viene eseguito, completando il primo `step` di label2. (1 elemento nella coda)
4. `console.log(1)` viene eseguito, completando il primo `step` di startLabel. (0 elementi in coda)
5. Ora viene eseguita la richiesta goNext e viene eseguito il secondo `step` di startLabel. (1 elemento nella coda)
6. `console.log(3)` viene eseguito, completando il secondo `step` di startLabel. (0 elementi in coda)

</Accordion>

<Accordion title="Check if can go to the next step" id="can-go-next">

È possibile utilizzare la proprietà `narration.canGoNext` per verificare se lo `step` successivo può essere eseguito.

`narration.canGoNext` è `false` quando:

- Uno `step` sta correndo
- Il giocatore deve <DynamicLink href="/start/choices">fare una scelta</DynamicLink>
- Il giocatore deve <DynamicLink href="/start/input">inserire un valore</DynamicLink>

```tsx title="components/NextButton.tsx"
import { narration } from '@drincs/pixi-vn'

function NextButton() {
    return (
        <button disabled={!narration.canGoNext} onClick={() => {
            narration.goNext({})
        }}>
            Next
        </button>
    )
}
```

</Accordion>

</Accordions>

### Torna indietro

<Callout title="UI screen" type="info">

Potete trovare l'esempio del pulsante Indietro nella sezione <DynamicLink href="/start/interface-examples#go-back">esempi di interfaccia</DynamicLink>.

</Callout>

Ad ogni `step`, il sistema salva lo stato attuale del gioco. Per tornare allo `step` precedente, utilizza la funzione `stepHistory.goBack()`.

You must pass a function `navigate: (path: string) => void` as a parameter. This function will be called with the <DynamicLink href="/start/start/interface-navigate">URL Path or Route</DynamicLink> of the previous `step`, so you can <DynamicLink href="/start/interface-navigate">navigate to the previous UI screen</DynamicLink>.

For example, if you use [React Router Dom](https://reactrouter.com):

```typescript
import { stepHistory } from '@drincs/pixi-vn'
import { useNavigate } from 'react-router-dom';

const navigate = useNavigate();

if (stepHistory.canGoBack) {
    stepHistory.goBack(navigate).then(() => {
        // ...
    })
}
```

<Accordions>

<Accordion title="Check if can go back" id="can-go-back">

È possibile utilizzare la proprietà `stepHistory.canGoBack` per verificare se è possibile tornare indietro.

`stepHistory.canGoBack` è `false` quando nella cronologia non ci sono `steps` da ripristinare.

```tsx title="components/BackButton.tsx"
import { stepHistory } from '@drincs/pixi-vn'

function BackButton() {
    return (
        <button disabled={!stepHistory.canGoBack} onClick={() => {
            stepHistory.goBack({})
        }}>
            Back
        </button>
    )
}
```

</Accordion>

<Accordion title="Block the possibility of going back" id="block-the-possibility-of-going-back">

È possibile bloccare il "go back" chiamando `stepHistory.blockGoBack()`.

```typescript
import { stepHistory } from '@drincs/pixi-vn'

stepHistory.blockGoBack()
```

</Accordion>

</Accordions>

## Chiudere le label

<Accordions>

<Accordion title="Close current label" id="close-current-label">

Per chiudere la `label` corrente, utilizza la funzione `narration.closeCurrentLabel()`.

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeCurrentLabel()
```

</Accordion>

<Accordion title="Close all labels" id="close-all-labels">

Per chiudere tutte le `labels`, utilizza la funzione `narration.closeAllLabels()`.\
**Se si chiama questa funzione e in seguito non si richiama alcuna `label`, il <DynamicLink href="/start/other-narrative-features#how-manage-the-end-of-the-game">gioco terminerà</DynamicLink>.**

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeAllLabels()
```

</Accordion>

</Accordions>
