---
title: Gestisci il flusso di narrazione con le label
description: Descrive come controllare il flusso narrativo in Pixi'VN utilizzando le label, tra cui le funzioni di chiamata, salto e chiusura.
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

The narration flow is managed by functions such as `call`, `jump`, `continue`, `back`, and `closeLabel`, all available in the `narration` object.

## Esegui una label

<Accordions>

<Accordion title="Call a label" id="call-a-label">

To call a `label`, use the `narration.call` function.
Questa funzione ha i seguenti parametri:

- `label`: la `label` da chiamare
- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

Quando si chiama una `label`, viene eseguito il primo `step` di quella `label`. Se prima della chiamata era in esecuzione un'altra `label`, i `steps` rimanenti della `label` precedente riprenderanno al termine della `label` chiamata.

Ad esempio, se il gioco sta eseguendo lo `step` 5 della `label` A e tu **chiami** la `label` B, dopo che tutti i `passaggi` della `label` B sono stati eseguiti, il gioco continuerà con lo `step` 6 della `label` A.

`narration.call` returns the <DynamicLink href="/start/labels#all-steps-result">result of the first `step` of the called `label`</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.call(startLabel, {})
```

If you execute `narration.call` inside a `step`, you should return the result of `narration.call` and use `await`. In questo modo si garantisce una corretta gestione della cronologia.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.call(TestLabel, props)
        },
        async (props) => await narration.call(TestLabel, props),
    ]
)
```

</Accordion>

<Accordion title="Jump to a label" id="jump-to-a-label">

To jump to a `label`, use the `narration.jump` function.
Questa funzione ha i seguenti parametri:

- `label`: la `label` a cui saltare
- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

Quando si salta a una `label`, gli `steps` della `label` corrente vengono interrotti e iniziano gli `steps` della nuova `label`.

Ad esempio, se il gioco sta eseguendo lo `step` 5 della `label` A e tu **chiami** la `label` B, ma poi **salti** alla `label` C, dopo che la `label` C è terminata, il gioco continuerà con lo `step` 6 della `label` A. Quando salti alla `label` C, la `label` B verrà chiusa.

`narration.jump` returns the <DynamicLink href="/start/labels#all-steps-result">result of the first `step` of the called `label`</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

narration.jump(startLabel, {})
```

If you execute `narration.jump` inside a `step`, you should return the result of `narration.jump` and use `await`. In questo modo si garantisce che si attenda il primo `step` della nuova `label`.

```ts title="labels/startLabel.ts"
import { narration } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label",
    [
        async (props) => {
            return await narration.jump(TestLabel, props)
        },
        async (props) => await narration.jump(TestLabel, props),
    ]
)
```

</Accordion>

</Accordions>

## Continue and go back in steps

### Continue

<Callout title="UI screen" type="info">

You can find the example of the "continue" button in the <DynamicLink href="/start/interface-examples#go-next">interface examples</DynamicLink> section.

</Callout>

To execute the next `step`, use the `narration.continue()` function.
Questa funzione ha i seguenti parametri:

- `props`: le proprietà da passare alla `label`. L'interfaccia corrisponde a <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps`</DynamicLink>.

```ts
import { narration } from '@drincs/pixi-vn'

await narration.continue({})
```

`narration.continue()` is asynchronous, so you can use `.then` to, for example, disable a "Next" button until the `step` is complete.

```ts
import { narration } from '@drincs/pixi-vn'

// disable next button
narration.continue({})
    .then((result) => {
        // enable next button
    })
```

<Accordions>

<Accordion title="Call continue inside a step" id="call-gonext-inside-a-step">

If you call `narration.continue()` inside a `step`, the "continue" request will be queued and executed when the queue is empty.

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        narration.continue(props)
    },
])
```

Ecco un esempio per illustrare il funzionamento della coda:

```ts title="labels/startLabel.ts"
import { narration, newLabel } from '@drincs/pixi-vn'

export const startLabel = newLabel("start_label", [
    async (props) => {
        await narration.call(label2, props);
        console.log(1);
    },
    () => {
        console.log(3);
    },
])

const label2 = newLabel("label_02", [
    async (props) => {
        await narration.continue(props);
        console.log(2);
    },
])
```

In questo esempio, l'output sarà `2`, `1`, `3`. I passaggi sono:

1. `await narration.call(label2, props)` calls label2 and awaits its first `step`. (1 elemento nella coda)
2. The first `step` of label2 executes `await narration.continue(props)`, but the continue request is queued because the queue is not empty. (2 elementi in coda)
3. `console.log(2)` viene eseguito, completando il primo `step` di label2. (1 elemento nella coda)
4. `console.log(1)` viene eseguito, completando il primo `step` di startLabel. (0 elementi in coda)
5. Now the continue request is executed, and the second `step` of startLabel runs. (1 elemento nella coda)
6. `console.log(3)` viene eseguito, completando il secondo `step` di startLabel. (0 elementi in coda)

</Accordion>

<Accordion title="Check if can go to the next step" id="can-go-next">

È possibile utilizzare la proprietà `narration.canGoNext` per verificare se lo `step` successivo può essere eseguito.

`narration.canGoNext` è `false` quando:

- Uno `step` sta correndo
- Il giocatore deve <DynamicLink href="/start/choices">fare una scelta</DynamicLink>
- Il giocatore deve <DynamicLink href="/start/input">inserire un valore</DynamicLink>

```tsx title="components/NextButton.tsx"
import { narration } from '@drincs/pixi-vn'

function NextButton() {
    return (
        <button disabled={!narration.canGoNext} onClick={() => {
            narration.continue({})
        }}>
            Next
        </button>
    )
}
```

</Accordion>

</Accordions>

### Torna indietro

<Callout title="UI screen" type="info">

Potete trovare l'esempio del pulsante Indietro nella sezione <DynamicLink href="/start/interface-examples#go-back">esempi di interfaccia</DynamicLink>.

</Callout>

Ad ogni `step`, il sistema salva lo stato attuale del gioco. To go back to the previous `step`, use the `stepHistory.back()` function.

You must pass a function `navigate: (path: string) => void` as a parameter. This function will be called with the <DynamicLink href="/start/start/interface-navigate">URL Path or Route</DynamicLink> of the previous `step`, so you can <DynamicLink href="/start/interface-navigate">navigate to the previous UI screen</DynamicLink>.

For example, if you use [React Router Dom](https://reactrouter.com):

```typescript
import { stepHistory } from '@drincs/pixi-vn'
import { useNavigate } from 'react-router-dom';

const navigate = useNavigate();

if (stepHistory.canGoBack) {
    stepHistory.back(navigate).then(() => {
        // ...
    })
}
```

<Accordions>

<Accordion title="Check if can go back" id="can-go-back">

È possibile utilizzare la proprietà `stepHistory.canGoBack` per verificare se è possibile tornare indietro.

`stepHistory.canGoBack` è `false` quando nella cronologia non ci sono `steps` da ripristinare.

```tsx title="components/BackButton.tsx"
import { stepHistory } from '@drincs/pixi-vn'

function BackButton() {
    return (
        <button disabled={!stepHistory.canGoBack} onClick={() => {
            stepHistory.back({})
        }}>
            Back
        </button>
    )
}
```

</Accordion>

<Accordion title="Block the possibility of going back" id="block-the-possibility-of-going-back">

È possibile bloccare il "go back" chiamando `stepHistory.blockGoBack()`.

```typescript
import { stepHistory } from '@drincs/pixi-vn'

stepHistory.blockGoBack()
```

</Accordion>

</Accordions>

## Chiudere le label

<Accordions>

<Accordion title="Close current label" id="close-current-label">

Per chiudere la `label` corrente, utilizza la funzione `narration.closeCurrentLabel()`.

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeCurrentLabel()
```

</Accordion>

<Accordion title="Close all labels" id="close-all-labels">

Per chiudere tutte le `labels`, utilizza la funzione `narration.closeAllLabels()`.\
**Se si chiama questa funzione e in seguito non si richiama alcuna `label`, il <DynamicLink href="/start/other-narrative-features#how-manage-the-end-of-the-game">gioco terminerà</DynamicLink>.**

```typescript
import { narration } from '@drincs/pixi-vn'

narration.closeAllLabels()
```

</Accordion>

</Accordions>
