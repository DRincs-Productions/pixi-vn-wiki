---
title: Ticker
---
import { MoveExample, RotateExample, FadeExample, ZoomExample, MirrorExample, SpecialPropertiesExample } from "@/components/examples";

Pixi’VN provides the possibility to animate the canvas components with the tickers.

**What is a ticker?** A ticker is a class that runs at every frame and executes a function. It can be used to animate components, perform transitions, or execute any logic that needs to be updated regularly.

The tickers, compared to `PixiJS.tickers`, are classes with a `fn` method that is executed at every frame. This method is used to animate the canvas components. Pixi’VN keeps track of all running tickers, detects when they are no longer used and allows you to pause, resume, and delete them with <DynamicLink href="/start/canvas-tickers-functions">various methods</DynamicLink>.

## Create your own ticker

Create your own ticker is very simple, you just need to extend the <DynamicLink href="/start/canvas-tickers-functions">TickerBase</DynamicLink> class, override the `fn` method and implement your own logic.

After that, you must decorate the class with the `@tickerDecorator` decorator. The decorator can receive a string that represents the alias of the ticker. If the alias is not provided, the class name will be used as the alias.

For example:

```typescript title="canvas/tickers/RotateTicker.ts"
import { canvas, Container, TickerBase, tickerDecorator, TickerValue } from "@drincs/pixi-vn";

@tickerDecorator() // or @tickerDecorator('RotateTicker')
export default class RotateTicker extends TickerBase<{ speed?: number; clockwise?: boolean }> {
    fn(
        t: TickerValue,
        args: {
            speed?: number;
            clockwise?: boolean;
        },
        aliases: string[]
    ): void {
        let speed = args.speed === undefined ? 0.1 : args.speed;
        let clockwise = args.clockwise === undefined ? true : args.clockwise;
        aliases.forEach((alias) => {
            let component = canvas.find(alias);
            if (component && component instanceof Container) {
                if (clockwise) component.rotation += speed * t.deltaTime;
                else component.rotation -= speed * t.deltaTime;
            }
        });
    }
}
```
