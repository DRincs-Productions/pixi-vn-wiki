---
title: Menù a scelta
description: Spiega come implementare e personalizzare i menu di scelta interattivi in Pixi'VN, consentendo ai giocatori di prendere decisioni che influenzano la storia.
---

import { ChoiceMenus, ChoicesAlreadyMade } from "@/components/examples";

<Callout title="UI screen" type="info">

Un esempio della schermata dell'interfaccia utente del menu di scelta è disponibile nella sezione <DynamicLink href="/start/interface-examples#choice-menu">esempi di interfaccia</DynamicLink>.

</Callout>

<Callout title="ink" type="info">

È possibile utilizzare questo metodo con la sintassi _ink_. Scopri di più <DynamicLink href="/ink/choices">qui</DynamicLink>.

</Callout>

Nelle visual novel, i menu di scelta consentono al giocatore di prendere decisioni che influenzano la storia.

In Pixi'VN puoi chiedere al giocatore di fare una scelta. Ogni scelta può avviare una `label` o chiudere il menu delle scelte.

## Richiedi al giocatore di fare una scelta

Per richiedere al giocatore di effettuare una scelta, impostare `narration.choices` con un array di `StoredChoiceInterface`. Per creare un oggetto `StoredChoiceInterface`, usa:

<Accordions>

<Accordion title="newChoiceOption" id="newchoiceoption">

In Pixi'VN, puoi creare un'opzione di menu di scelta utilizzando la funzione `newChoiceOption`.
Questa funzione ha i seguenti parametri:

- `text`: Il testo visualizzato nel menu di scelta.
- `label`: la <DynamicLink href="/start/labels#label">`label`</DynamicLink> da chiamare quando il giocatore seleziona l'opzione.
- `props`: Le proprietà passate alla `label`. Se `label` non richiede parametri, passare un oggetto vuoto `{}`.
- `options` (Opzionale): Un oggetto con le opzioni di `choice`:
  - `type`: Come verrà eseguita la <DynamicLink href="/start/labels-flow#run-a-label">label</DynamicLink>. Può essere `call` o `jump`. Il valore predefinito è `call`.
  - `oneTime`: Se `true`, la scelta può essere effettuata solo una volta.
  - `onlyHaveNoChoice`: Se `true`, la scelta viene mostrata solo se non ci sono altre scelte.
  - `autoSelect`: Se è `true` ed è l'unica scelta, verrà selezionata automaticamente.

</Accordion>

<Accordion title="newCloseChoiceOption" id="newclosechoiceoption">

Oltre a `newChoiceOption`, puoi usare `newCloseChoiceOption` per creare un'opzione di chiusura. Questo chiude il menu di scelta e continua con gli <DynamicLink href="/start/labels">step</DynamicLink>, senza richiamare alcuna <DynamicLink href="/start/labels#label">label</DynamicLink>.
Questa funzione ha i seguenti parametri:

- `text`: Il testo visualizzato nel menu di scelta.
- `options` (Opzionale): Un oggetto con le opzioni di `choice`:
  - `closeCurrentLabel`: Se `true`, la `label` corrente verrà chiusa. Il valore predefinito è `false`.
  - `oneTime`: Se `true`, la scelta può essere effettuata solo una volta.
  - `onlyHaveNoChoice`: Se `true`, la scelta viene mostrata solo se non ci sono altre scelte.
  - `autoSelect`: Se è `true` ed è l'unica scelta, verrà selezionata automaticamente.

</Accordion>

</Accordions>

```ts title="labels/startLabel.ts"
import { newChoiceOption, newCloseChoiceOption, narration, newLabel } from "@drincs/pixi-vn"

export const startLabel = newLabel("start_label",
    [
        async () => {
            narration.dialogue = "Choose a fruit:"
            narration.choices = [ // [!code focus]
                newChoiceOption("Orange", orangeLabel, {}), // by default, the label will be called with "call" // [!code focus]
                newChoiceOption("Banana", bananaLabel, {}, { type: "jump" }), // [!code focus]
                newChoiceOption("Apple", appleLabel, { quantity: 5 }, { type: "call" }), // [!code focus]
                newCloseChoiceOption("Cancel"), // [!code focus]
            ] // [!code focus]
        },
        () => { narration.dialogue = "Restart" },
        async (props) => await narration.jump("start_label", props)
    ],
)
```

<ChoiceMenus />

## Ottieni

Per ottenere il menu di scelta corrente, usa `narration.choices`. Restituisce un array di `StoredChoiceInterface`.

```typescript
const menuOptions: StoredChoiceInterface[] = narration.choices;
```

## Richiesta

Per selezionare un'opzione, utilizzare `narration.selectChoice`.

```typescript
const item = narration.choices![0]; // get the first item

narration.selectChoice(item, {
    // Add StepLabelProps here
    navigate: navigate, // example
    // And the props to pass to the label
    ...item.props
})
    .then(() => {
        // ...
    })
    .catch((e) => {
        // ...
    })
```

## Rimuovi

Per cancellare le opzioni di scelta, imposta `narration.choices = undefined`.

```typescript
narration.choices = undefined;
```

## Classe personalizzata

È possibile personalizzare un'opzione del menu di scelta aggiungendo proprietà all'interfaccia `ChoiceInterface`. Ad esempio, aggiungi una proprietà `icon` per visualizzare un'icona.

Sostituisci l'interfaccia `ChoiceInterface` nel tuo file `.d.ts`:

```ts tab="pixi-vn.d.ts"
declare module '@drincs/pixi-vn' {
    interface ChoiceInterface {
        icon?: string
    }
}
```

```ts tab="labels/startLabel.ts"
narration.choices = [
    newChoiceOption("Orange", orangeLabel, {}, { icon: "orange.png" }),
    newChoiceOption("Banana", bananaLabel, {}, { icon: "banana.png" }),
    newChoiceOption("Apple", appleLabel, {}, { icon: "apple.png" }),
]
```

```tsx tab="screens/ChoiceMenu.tsx"
function ChoiceMenu({ choices }: { choices: StoredIndexedChoiceInterface[] }) {
    return (
        <div>
            {choices.map((choice, index) => (
                <div key={index}>
                    {choice.icon && <img src={choice.icon} alt={choice.text} />}
                    <button onClick={() => narration.selectChoice(choice)}>{choice.text}</button>
                </div>
            ))}
        </div>
    )
}
```

## Altre funzionalità

<Accordions>

<Accordion title="Choices already made" id="choices-already-made">

Per ottenere le scelte già effettuate nel `step` corrente, utilizzare `narration.alreadyCurrentStepMadeChoices`.

```ts tab="hooks/useQueryInterface.ts"
import { narration } from "@drincs/pixi-vn";
import { useQuery } from "@tanstack/react-query";

export const INTERFACE_DATA_USE_QUEY_KEY = "interface_data_use_quey_key";

const CHOICE_MENU_OPTIONS_USE_QUEY_KEY = "choice_menu_options_use_quey_key";
export function useQueryChoiceMenuOptions() {
    return useQuery({
        queryKey: [INTERFACE_DATA_USE_QUEY_KEY, CHOICE_MENU_OPTIONS_USE_QUEY_KEY],
        queryFn: async () =>
            narration.choices?.map((option) => ({
                ...option,
                text: typeof option.text === "string" ? option.text : option.text.join(" "),
                alreadyChosen: // [!code ++]
                    narration.alreadyCurrentStepMadeChoices?.find((index) => index === option.choiceIndex) !== // [!code ++]
                    undefined, // [!code ++]
            })) || [],
    });
}
```

```tsx tab="screens/ChoiceMenu.tsx"
import useNarrationFunctions from "../hooks/useNarrationFunctions";
import { useQueryChoiceMenuOptions } from "../hooks/useQueryInterface";

export default function ChoiceMenu() {
    const { data: menu = [] } = useQueryChoiceMenuOptions();
    const { selectChoice } = useNarrationFunctions();

    return (
        <div
            style={{
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center",
                width: "100%",
                height: "100%",
                overflow: "auto",
                gap: "8px",
                maxHeight: "100%",
                margin: 0,
                pointerEvents: menu?.length > 0 ? "auto" : "none",
            }}
        >
            {menu?.map((item, index) => (
                <button
                    key={"choice-" + index}
                    style={{
                        justifyContent: "center",
                        alignItems: "center",
                    }}
                    onClick={() => selectChoice(item)}
                >
                    {item.alreadyChosen ? "✓ " : ""} // [!code ++]
                    {item.text}
                </button>
            ))}
        </div>
    );
}
```

<ChoicesAlreadyMade />

</Accordion>

</Accordions>
