---
title: Navigare/passare da una schermata all'altra dell'UI
description: Scopri come navigare tra le diverse schermate dell'interfaccia utente in Pixi'VN utilizzando i sistemi di routing.
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

Per passare da una schermata all'altra dell'interfaccia utente (senza interrompere il canvas), è possibile utilizzare popup e finestre modali oppure navigare tra diversi **percorsi/route URL**.

**Cosa sono i percorsi/route URL?** I **percorsi/route URL** sono le parti dell'URL che seguono il dominio. Ad esempio, nell'URL `https://example.com/path/to/page`, la route è `/path/to/page`. In genere, in tutti i progetti web front-end (client), ogni percorso è collegato a una pagina web (schermata dell'interfaccia utente).

È possibile utilizzare un sistema di routing per gestire la navigazione tra **percorsi/route URL**. Ad esempio, puoi usare:

- [React Router](https://reactrouter.com/)
- [Vue Router](https://router.vuejs.org/)
- [Angular Router](https://angular.io/guide/router)
- [TanStack Router](https://tanstack.com/router/latest)

```tsx tab="React Router"
import { Route, Routes } from "react-router-dom";
import LoadingScreen from "./screens/LoadingScreen";
import MainMenu from "./screens/MainMenu";
import NarrationElement from "./screens/NarrationElement";

export default function AppRoutes() {
    return (
        <Routes>
            <Route key={"main_menu"} path={"/"} element={<MainMenu />} />
            <Route key={"loading"} path={"/loading"} element={<LoadingScreen />} />
            <Route key={"narration"} path={"/narration"} element={<NarrationElement />} />
            <Route path='*' element={<MainMenu />} />
        </Routes>
    );
}
```

```vue tab="Vue Router"
<script setup>
import { createRouter, createWebHistory } from 'vue-router'
import MainMenu from './screens/MainMenu.vue'
import LoadingScreen from './screens/LoadingScreen.vue'
import NarrationElement from './screens/NarrationElement.vue'

const routes = [
  { path: '/', component: MainMenu },
  { path: '/loading', component: LoadingScreen },
  { path: '/narration', component: NarrationElement },
  { path: '/:pathMatch(.*)*', component: MainMenu }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
</script>
```

```typescript tab="Angular Router"
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { MainMenuComponent } from './screens/main-menu.component';
import { LoadingScreenComponent } from './screens/loading-screen.component';
import { NarrationElementComponent } from './screens/narration-element.component';

const routes: Routes = [
  { path: '', component: MainMenuComponent },
  { path: 'loading', component: LoadingScreenComponent },
  { path: 'narration', component: NarrationElementComponent },
  { path: '**', component: MainMenuComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

```tsx tab="TanStack Router"
import { Router, Route } from '@tanstack/router'
import MainMenu from './screens/MainMenu'
import LoadingScreen from './screens/LoadingScreen'
import NarrationElement from './screens/NarrationElement'

const router = new Router({
  routeTree: (
    <>
      <Route path="/" element={<MainMenu />} />
      <Route path="/loading" element={<LoadingScreen />} />
      <Route path="/narration" element={<NarrationElement />} />
      <Route path="*" element={<MainMenu />} />
    </>
  )
})

export default router
```

## Come navigare tra le route?

Per navigare tra i percorsi, utilizza la funzione di navigazione fornita dal sistema di routing.

<Callout title="Templates" type="info">

In tutti i template, l'interfaccia `StepLabelProps` è già estesa per includere una funzione `navigate`. La puoi trovare nel file `pixi-vn.d.ts`.

</Callout>

Nei progetti pixi-vn è molto comune dover navigare tra i percorsi durante la narrazione. To enable this, the navigation function must be included in the <DynamicLink href="/start/labels#steplabelprops">`StepLabelProps` interface</DynamicLink>.

```ts tab="pixi-vn.d.ts"
import { narration } from '@drincs/pixi-vn'

declare module '@drincs/pixi-vn' {
    interface StepLabelProps {
        navigate: (route: string) => void,
    }
}
```

```ts tab="hooks/useGameProps.ts"
import { StepLabelProps } from "@drincs/pixi-vn";
import useMyNavigate from "./useMyNavigate";

export default function useGameProps(): StepLabelProps {
    const navigate = useMyNavigate();

    return {
        navigate,
    };
}
```

<Callout title="ink" type="info">

In tutti i template di ink è stato introdotto uno <DynamicLink href="/ink/ink-hashtag">script hashtag personalizzato</DynamicLink> per navigare tra i percorsi.

La sintassi è la seguente:

```ink
# navigate [route]
```

- `route`: The destination route/path. For example, `# navigate /new-route`.

</Callout>

So, when you create a new label, you can use the `navigate` function to switch between routes:

```ts tab="labels/startLabel.ts"
export const startLabel = newLabel("start_label",
    [
        ({ navigate }) => { // [!code focus]
            navigate("/new-route") // [!code focus]
        }, // [!code focus]
    ]
)
```

<Accordions>

<Accordion title="Block the browser's back and forward buttons" id="block-back-forward">

Using the browser's back and forward buttons can cause the game to be in an inconsistent state. This is because those keys allow the player to navigate between routes, not between narrative `steps`.

It is recommended to prevent the path from changing when the browser's back button is pressed. There are many ways to do this, but the following approach is suggested:

Intercept the `popstate` event, which is triggered after the back button is pressed, and immediately go forward one step. This means that when the back button is pressed, it returns to the previous path for a short time and then immediately returns to the current path. To ensure the path does not change, even briefly, you can add two nodes to the history every time you navigate to a new path, instead of one (the default).

Example:

```ts title="EventInterceptor.ts"
import { useEffect } from 'react';

export default function EventInterceptor() {
    useEffect(() => {
        window.addEventListener("popstate", onpopstate);
        return () => {
            window.removeEventListener("popstate", onpopstate);
        };
    }, []);

    function onpopstate() {
        window.history.forward();
    }

    return null
}
```

```tsx title="React example"
import { Assets } from "@drincs/pixi-vn";
import { NavigateFunction, NavigateOptions, To, useNavigate } from "react-router-dom";

export default function useMyNavigate(): NavigateFunction {
    const navigate = useNavigate();

    return async (to: To | number, options?: NavigateOptions) => {
        if (typeof to === "number") {
            await navigate(to);
        } else {
            Assets.backgroundLoadBundle(to as string);
            await navigate(to, options);
        }
        window.history.pushState(null, window.location.href, window.location.href);
    };
}
```

</Accordion>

</Accordions>
